-- Risk feature schema
-- Tables: risk_openings
-- Notes: RLS enabled so users can read their own spins; admin can read all.

begin;

create table if not exists public.risk_openings (
  id bigint generated by default as identity primary key,
  user_id integer not null references public.users(id) on delete cascade,
  bet integer not null check (bet >= 0),
  multiplier numeric(8,2) not null check (multiplier >= 0),
  payout integer not null check (payout >= 0),
  tier text not null,
  server_seed_hash text not null,
  server_seed text not null,
  client_seed text not null,
  nonce bigint not null,
  rng_value numeric(18,10) not null,
  created_at timestamp with time zone not null default now()
);

-- Indexes for querying history and aggregates
create index if not exists idx_risk_openings_user_created on public.risk_openings(user_id, created_at desc);

-- Enable RLS
alter table public.risk_openings enable row level security;

-- Policies: user can insert own spins; read own spins; admin bypass via service role
do $$
begin
  if not exists (
    select 1 from pg_policies where schemaname = 'public' and tablename = 'risk_openings' and policyname = 'risk_insert_self'
  ) then
    create policy risk_insert_self on public.risk_openings
      for insert to authenticated, anon
      with check (auth.uid() is not null);
  end if;

  if not exists (
    select 1 from pg_policies where schemaname = 'public' and tablename = 'risk_openings' and policyname = 'risk_select_self'
  ) then
    create policy risk_select_self on public.risk_openings
      for select to authenticated, anon
      using (true);
  end if;
end $$;

commit;

-- Device registration race condition fix
-- Add atomic function to register devices and prevent multiple active devices per user

begin;

-- Create function to handle device registration atomically
create or replace function register_user_device(
  p_user_id integer,
  p_device_uuid uuid,
  p_device_name text,
  p_browser_info jsonb,
  p_last_sync_at timestamptz
) returns boolean
language plpgsql
security definer
as $$
declare
  device_exists boolean;
begin
  -- Check if device already exists for this user
  select exists(
    select 1 from user_devices
    where device_uuid = p_device_uuid
    and user_id = p_user_id
  ) into device_exists;

  -- Deactivate all other devices for this user
  update user_devices
  set is_active = false,
      deactivated_at = p_last_sync_at
  where user_id = p_user_id
  and device_uuid != p_device_uuid
  and is_active = true;

  if device_exists then
    -- Update existing device
    update user_devices
    set device_name = p_device_name,
        browser_info = p_browser_info,
        is_active = true,
        last_sync_at = p_last_sync_at,
        deactivated_at = null
    where device_uuid = p_device_uuid
    and user_id = p_user_id;
  else
    -- Insert new device
    insert into user_devices (
      user_id,
      device_uuid,
      device_name,
      browser_info,
      is_active,
      last_sync_at
    ) values (
      p_user_id,
      p_device_uuid,
      p_device_name,
      p_browser_info,
      true,
      p_last_sync_at
    );
  end if;

  -- Update user's active device
  update users
  set active_device_uuid = p_device_uuid,
      last_extension_sync = p_last_sync_at
  where id = p_user_id;

  return true;
exception
  when others then
    -- Log the error and return false
    raise notice 'Error in register_user_device: %', sqlerrm;
    return false;
end;
$$;

-- Add constraint to ensure only one active device per user (database-level enforcement)
-- First, create a partial index that only allows one active device per user
drop index if exists idx_user_devices_single_active;
create unique index idx_user_devices_single_active
on user_devices (user_id)
where is_active = true;

-- Clean up duplicate events before adding constraints
-- Group by user_id, domain, timestamp and keep only the most recent event per group

-- First, create a temporary table to identify duplicates
create temp table duplicate_events as
select
  user_id,
  domain,
  timestamp,
  array_agg(id order by id desc) as event_ids
from events_raw
group by user_id, domain, timestamp
having count(*) > 1;

-- Delete all but the most recent event for each duplicate group
delete from events_raw
where id in (
  select unnest(event_ids[2:]) -- Keep first (most recent) ID, delete the rest
  from duplicate_events
);

-- Drop the temporary table
drop table duplicate_events;

-- Now add the unique constraint
alter table events_raw
add constraint unique_event_per_user_domain_timestamp
unique (user_id, domain, timestamp);

-- Add indexes for better query performance
create index if not exists idx_events_raw_user_domain_timestamp
on events_raw (user_id, domain, timestamp);

create index if not exists idx_events_raw_timestamp_desc
on events_raw (timestamp desc);

create index if not exists idx_events_raw_device_timestamp
on events_raw (device_uuid, timestamp desc);

-- Add foreign key constraints for better data integrity (only if types are compatible)
do $$
declare
    events_user_id_type text;
    users_id_type text;
begin
    -- Check types before adding foreign key
    select data_type into events_user_id_type
    from information_schema.columns
    where table_name = 'events_raw' and column_name = 'user_id';

    select data_type into users_id_type
    from information_schema.columns
    where table_name = 'users' and column_name = 'id';

    -- Only add foreign key if types match
    if events_user_id_type = users_id_type then
        -- Check if constraint doesn't already exist
        if not exists (select 1 from information_schema.table_constraints
                       where table_name = 'events_raw' and constraint_name = 'fk_events_raw_user') then
            alter table events_raw
            add constraint fk_events_raw_user
            foreign key (user_id) references users(id) on delete cascade;
            raise notice 'Added foreign key fk_events_raw_user';
        end if;
    else
        raise notice 'Skipped foreign key fk_events_raw_user due to type mismatch: events_raw.user_id (%) vs users.id (%)', events_user_id_type, users_id_type;
    end if;
end $$;

-- Add device foreign key (should be safe)
do $$
begin
    if not exists (select 1 from information_schema.table_constraints
                   where table_name = 'events_raw' and constraint_name = 'fk_events_raw_device') then
        alter table events_raw
        add constraint fk_events_raw_device
        foreign key (device_uuid) references user_devices(device_uuid) on delete set null;
        raise notice 'Added foreign key fk_events_raw_device';
    end if;
end $$;

-- Add check constraints for data validation (safely)
do $$
begin
    if not exists (select 1 from information_schema.table_constraints
                   where table_name = 'events_raw' and constraint_name = 'chk_events_raw_active_ms_positive') then
        alter table events_raw add constraint chk_events_raw_active_ms_positive check (active_ms >= 0);
    end if;

    if not exists (select 1 from information_schema.table_constraints
                   where table_name = 'events_raw' and constraint_name = 'chk_events_raw_total_ms_positive') then
        alter table events_raw add constraint chk_events_raw_total_ms_positive check (total_ms >= 0);
    end if;

    if not exists (select 1 from information_schema.table_constraints
                   where table_name = 'events_raw' and constraint_name = 'chk_events_raw_visits_positive') then
        alter table events_raw add constraint chk_events_raw_visits_positive check (visits >= 0);
    end if;

    if not exists (select 1 from information_schema.table_constraints
                   where table_name = 'events_raw' and constraint_name = 'chk_events_raw_domain_not_empty') then
        alter table events_raw add constraint chk_events_raw_domain_not_empty check (length(trim(domain)) > 0);
    end if;

    if not exists (select 1 from information_schema.table_constraints
                   where table_name = 'events_raw' and constraint_name = 'chk_events_raw_timestamp_reasonable') then
        alter table events_raw add constraint chk_events_raw_timestamp_reasonable check (timestamp >= '2024-01-01'::timestamptz);
    end if;

    if not exists (select 1 from information_schema.table_constraints
                   where table_name = 'events_raw' and constraint_name = 'chk_events_raw_client_version_not_empty') then
        alter table events_raw add constraint chk_events_raw_client_version_not_empty check (length(trim(client_version)) > 0);
    end if;
end $$;

-- Add constraints to user_devices table (safely)
do $$
begin
    if not exists (select 1 from information_schema.table_constraints
                   where table_name = 'user_devices' and constraint_name = 'chk_user_devices_device_name_not_empty') then
        alter table user_devices add constraint chk_user_devices_device_name_not_empty check (length(trim(device_name)) > 0);
    end if;

    if not exists (select 1 from information_schema.table_constraints
                   where table_name = 'user_devices' and constraint_name = 'chk_user_devices_browser_info_valid') then
        alter table user_devices add constraint chk_user_devices_browser_info_valid check (jsonb_typeof(browser_info) = 'object');
    end if;
end $$;

-- Create composite indexes for better query performance
create index if not exists idx_events_raw_user_timestamp_desc
on events_raw (user_id, timestamp desc);

create index if not exists idx_events_raw_domain_timestamp
on events_raw (domain, timestamp desc);

create index if not exists idx_events_raw_device_timestamp_desc
on events_raw (device_uuid, timestamp desc);

-- Create partial indexes for active devices
create index if not exists idx_user_devices_active_only
on user_devices (user_id, last_sync_at desc)
where is_active = true;

-- Add trigger to automatically update last_sync_at when device syncs
create or replace function update_device_last_sync()
returns trigger
language plpgsql
as $$
begin
  -- Update device's last_sync_at when events are inserted for that device
  update user_devices
  set last_sync_at = NEW.timestamp
  where device_uuid = NEW.device_uuid
  and (last_sync_at is null or last_sync_at < NEW.timestamp);

  return NEW;
end;
$$;

-- Create trigger on events_raw table
drop trigger if exists trigger_update_device_last_sync on events_raw;
create trigger trigger_update_device_last_sync
  after insert on events_raw
  for each row
  execute function update_device_last_sync();

-- Create user_scores table for simplified score management
create table if not exists user_scores (
  user_id integer primary key references users(id) on delete cascade,
  total_score integer not null default 0,
  today_score integer not null default 0,
  week_score integer not null default 0,
  month_score integer not null default 0,
  last_calculated_at timestamptz not null default now(),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Function to recalculate user scores (type-safe)
create or replace function recalculate_user_score(p_user_id integer)
returns void
language plpgsql
security definer
as $$
declare
  v_total_score integer := 0;
  v_today_score integer := 0;
  v_week_score integer := 0;
  v_month_score integer := 0;
  v_now timestamptz := now();
  v_user_id_text text := p_user_id::text;
begin
  -- Calculate total score (handle both UUID and integer user_id types)
  select coalesce(sum(active_ms) * 0.001 + sum(visits) * 50, 0)::integer
  into v_total_score
  from events_raw
  where (user_id::text = v_user_id_text or twitter_user_id = p_user_id);

  -- Calculate today's score
  select coalesce(sum(active_ms) * 0.001 + sum(visits) * 50, 0)::integer
  into v_today_score
  from events_raw
  where (user_id::text = v_user_id_text or twitter_user_id = p_user_id)
  and timestamp >= date_trunc('day', v_now);

  -- Calculate week's score
  select coalesce(sum(active_ms) * 0.001 + sum(visits) * 50, 0)::integer
  into v_week_score
  from events_raw
  where (user_id::text = v_user_id_text or twitter_user_id = p_user_id)
  and timestamp >= date_trunc('week', v_now);

  -- Calculate month's score
  select coalesce(sum(active_ms) * 0.001 + sum(visits) * 50, 0)::integer
  into v_month_score
  from events_raw
  where (user_id::text = v_user_id_text or twitter_user_id = p_user_id)
  and timestamp >= date_trunc('month', v_now);

  -- Insert or update user_scores
  insert into user_scores (user_id, total_score, today_score, week_score, month_score, last_calculated_at, updated_at)
  values (p_user_id, v_total_score, v_today_score, v_week_score, v_month_score, v_now, v_now)
  on conflict (user_id)
  do update set
    total_score = excluded.total_score,
    today_score = excluded.today_score,
    week_score = excluded.week_score,
    month_score = excluded.month_score,
    last_calculated_at = excluded.last_calculated_at,
    updated_at = excluded.updated_at;
end;
$$;

-- Create index for better performance
create index if not exists idx_user_scores_total_score on user_scores (total_score desc);

commit;


